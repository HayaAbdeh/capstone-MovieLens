---
title: "MovieLens_Report"
author: "HayaAbdeh"
date: "20‏/6‏/2021"
output: html_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(DescTools)


knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

Data science is one of new techniques to describe big data  and extract knowledge by using new machine learning algorithms that analyze and process data into helpful information and naturally intuitive solutions.  and as machine learning improves the modern business making  in recent years, We can see Netflix one of the biggest companies that taken an active role as producer and distributor for both film and television series, worked on improving a recommendation system to attract more subscription users. 

We are going to mimic  a predict movie rating system for users in a large dataset, we train a linear model to generate predicted movie ratings and calculate  (RMSE) the Root Mean Square Error of the predicted ratings versus the actual ratings.
This is a four parts report that introduce the problem, and  develops the inquires in the summary, moreover  the method section establishes the model and implements in with the accompanying (R) file, and then shares the results in the conclusion section.


## Summary 
Dataset used is [MovieLens 10M dataset] (https://grouplens.org/datasets/movielens/10m/)
(http://files.grouplens.org/datasets/movielens/ml-10m.zip)
consists of 10 million ratings and 100,000 tag applications applied to 10,000 movies by 72,000 users , Varying numbers of ratings for each movie , and over 30,000 ratings and over 100 titles with a single rating.

```{r, initial_analysis, echo=TRUE}

dl <- tempfile()
download.file("http://files.grouplens.org/datasets/movielens/ml-10m.zip", dl)

ratings <- fread(text = gsub("::", "\t", readLines(unzip(dl, "ml-10M100K/ratings.dat"))),
                 col.names = c("userId", "movieId", "rating", "timestamp"))

movies <- str_split_fixed(readLines(unzip(dl, "ml-10M100K/movies.dat")), "\\::", 3)
colnames(movies) <- c("movieId", "title", "genres")

# if using R 4.0 or later:
movies <- as.data.frame(movies) %>% mutate(movieId = as.numeric(movieId),
                                            title = as.character(title),
                                            genres = as.character(genres))
movielens <- left_join(ratings, movies, by = "movieId")

# Validation set will be 10% of MovieLens data
set.seed(1, sample.kind="Rounding") # if using R 3.5 or earlier, use `set.seed(1)`
test_index <- createDataPartition(y = movielens$rating, times = 1, p = 0.1, list = FALSE)
edx <- movielens[-test_index,]
temp <- movielens[test_index,]
# Make sure userId and movieId in validation set are also in edx set
validation <- temp %>% 
      semi_join(edx, by = "movieId") %>%
      semi_join(edx, by = "userId")

# Add rows removed from validation set back into edx set
removed <- anti_join(temp, validation)
edx <- rbind(edx, removed)

rm(dl, ratings, movies, test_index, temp, movielens, removed)


# Most rated films
edx %>% group_by(title) %>%
  summarize(n_ratings = n()) %>%
  arrange(desc(n_ratings))
# Number of movies rated once
edx %>% group_by(title) %>%
  summarize(n_ratings = n()) %>%
  filter(n_ratings==1) %>%
  count() %>% pull()

#number of movie ratings in each of the following genres in the edx dataset

genre_List <- c('Drama', 'Comedy', 'Thriller', 'Romance')
genre_Counts <- sapply(genre_List, function(g){
     edx %>% filter(str_detect(genres, g)) %>% tally()
 })

edx %>% separaterows(genres, sep = "\\|") %>%
    group_by(genres) %>%
    summarize(count = n())



```


## Methods
As The dataset is split 90-10 on train and test sets respectively. The training set (edx) has 9,000,055 entries and 6 columns. and the test set (validation) has 999,998 entries and 6 columns.
So We will compute the average across every user and every movie as all of our predicted rating.


```{r just_average_model, echo=TRUE}
mu <- mean(edx$rating)
RMSE(validation$rating, mu)


```



#Add the movie bias term which calculate the average of the rankings for movies, 

```{r model, echo=TRUE}
movie_bias <- edx %>%
  group_by(movieId) %>%
  summarize(movie_bias = mean(rating - mu))


```
# predict ratings with mu 
```{r model, echo=TRUE}
predict_rat <- validation %>% 
  left_join(movie_bias, by='movieId') %>%
  mutate(pred = mu + movie_bias) %>%
  pull(pred)


RMSE(validation$rating, predict_rat)

```

#Now calculate user bias term. to minimizes the effect of extreme ratings made by users

```{r user bias, echo=TRUE}
# user bias 
user_bias <- edx %>% 
  left_join(movie_bias, by='movieId') %>%
  group_by(userId) %>%
  summarize(user_bias = mean(rating - mu - movie_bias))


```

# predict ratings with movie and user bias
```{r model, echo=TRUE}
predict_rat_new <- validation %>% 
  left_join(movie_bias, by='movieId') %>%
  left_join(user_bias, by='userId') %>%
  mutate(pred = mu + movie_bias + user_bias) %>%
  pull(pred)



RMSE(predicted_ratings, validation$rating)

```

#We use regularization to reduce the effect of bias because of extreme rating by the users on movies


# determine lambda from a sequence
```{r model, echo=TRUE}
lambda <- seq(from=0, to=10, by=0.25)
# output RMSE of each lambda
rmses <- sapply(lambda, function(l){
  # calculate average rating for training data
  mu <- mean(edx$rating)
  # compute regularized movie bias term
  movie_bias <- edx %>% 
    group_by(movieId) %>%
    summarize(movie_bias = sum(rating - mu)/(n()+l))
  # compute regularize user bias term
  user_bias <- edx %>% 
    left_join(movie_bias, by="movieId") %>%
    group_by(userId) %>%
    summarize(user_bias = sum(rating - movie_bias - mu)/(n()+l))
  # compute predictions on validation set
  predict_rat <- validation %>% 
    left_join(movie_bias, by = "movieId") %>%
    left_join(user_bias, by = "userId") %>%
    mutate(pred = mu + movie_bias + user_bias) %>%
    pull(pred)
  # return RMSE of the predictions
  return(RMSE(predict_rat, validation$rating))
})


```

## Including Plots



```{r pressure, echo=FALSE}
qplot(lambda, rmses)
```




## Results and conclusions

```{r final_lambda, echo=TRUE}
lam <-lambda[which.min(rmses)]


# compute regularize movie bias term
movie_bias <- edx %>% 
  group_by(movieId) %>%
  summarize(movie_bias = sum(rating - mu)/(n()+lam))
# compute regularize user bias term
user_bias <- edx %>% 
  left_join(movie_bias, by="movieId") %>%
  group_by(userId) %>%
  summarize(user_bias = sum(rating - movie_bias - mu)/(n()+lam))
# compute predictions on validation 
predict_rat <- validation %>% 
  left_join(movie_bias, by = "movieId") %>%
  left_join(user_bias, by = "userId") %>%
  mutate(pred = mu + movie_bias + user_bias) %>%
  pull(pred)
# report RMSE for the final model
RMSE(predict_rat, validation$rating)
```

##We had improved the value of RMSE as we regularized the biased model, the tichnique of linear model is simple and able to make prediction on movie ratings as well.


